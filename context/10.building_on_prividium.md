---
title: Building Applications on Prividium
description:
  Considerations and patterns for deploying smart contracts and building Web3 applications on Prividium chains.
---

This guide covers essential considerations and patterns for deploying smart contracts and building Web3 applications on
Prividium chains.

> [!NOTE] Architecture Overview
>
> For a high-level understanding of Prividium's architecture and components, see
> [Prividium Architecture](00.prividium_architecture.md).

## Table of Contents

1. [Deploying Smart Contracts](#deploying-smart-contracts)
2. [Configuring Contract Method Permissions](#configuring-contract-method-permissions)
3. [Application Configuration](#application-configuration)
4. [Authentication and OAuth Scopes](#authentication-and-oauth-scopes)
5. [RPC URL Architecture](#rpc-url-architecture)
6. [Network Configuration](#network-configuration)
7. [Browser Extension Wallets (MetaMask, etc.)](#browser-extension-wallets-metamask-etc)
8. [Scripting with Viem and Ethers](#scripting-with-viem-and-ethers)
9. [Reading from Contracts](#reading-from-contracts)
10. [Sending Transactions](#sending-transactions)
11. [Error Handling](#error-handling)
12. [Best Practices](#best-practices)

## Deploying Smart Contracts

### Prerequisites

All chain interactions require an authenticated user and permission to deploy contracts. If you try to deploy a contract
as you would on Ethereum mainnet or any other public chain, you'll get an error.

**Required:** Your user and wallet address must have permissions to deploy contracts.

### Deployment Options

You have three options for deploying contracts on Prividium:

#### Option 1: Use the Prividium Local Proxy

The `prividium` [NPM package](https://www.npmjs.com/package/prividium) includes a CLI tool that starts a local proxy to
automatically inject authentication headers in your requests to the Prividium RPC.

**Steps:**

1. Start the local proxy with the following command:

   ```bash
   npx prividium proxy \
     -r https://proxy.prividium.dev/ \
     -u https://user-panel.prividium.dev/
   ```

   Note that:
   - `-r` is the RPC URL of the Prividium proxy
   - `-u` is the URL of the user panel

2. This will:
   - Open the Prividium user panel
   - Request your authentication
   - Store your access token
   - Provide you with a local endpoint for your proxy server

3. Use the local endpoint to deploy your contracts. The proxy will inject the authentication headers and forward the
   request to the original RPC endpoint.

**Example usage:**

```bash
# After starting the proxy, use the local endpoint
forge script DeployScript \
  --rpc-url http://127.0.0.1:24101/rpc \
  --broadcast
```

#### Option 2: Handle Auth Token Manually in JavaScript/TypeScript

Write a script to call the Permissions API to retrieve a token for a whitelisted wallet address, then inject it into
your deployment script.

**Steps:**

1. Retrieve authentication token by calling the Permissions API
   [as detailed here](https://github.com/matter-labs/zksync-prividium/blob/main/experiments/sample-deploy-scripts/src/utils/get-crypto-native-auth.ts).

2. Inject the token in your deployment script using ethers or viem:
   - **Ethers example:**
     [as detailed here](https://github.com/matter-labs/zksync-prividium/blob/main/experiments/sample-deploy-scripts/src/utils/deploy-sample-contract.ts)
   - **Viem:** Similar pattern - create a custom transport that includes auth headers

**Example with ethers:**

```typescript
import { ethers } from 'ethers';
import { getAuthToken } from './utils/get-crypto-native-auth';

async function deploy() {
  // Get auth token
  const token = await getAuthToken(walletAddress);

  // Create provider with auth headers
  const provider = new ethers.JsonRpcProvider({
    url: process.env.RPC_URL || 'https://proxy.prividium.dev/rpc',
    headers: {
      Authorization: `Bearer ${token}`
    }
  });

  // Deploy contract
  const factory = new ethers.ContractFactory(abi, bytecode, wallet);
  const contract = await factory.connect(provider).deploy();
  await contract.waitForDeployment();
}
```

#### Option 3: Using `cast` (Foundry)

Use `cast` with manual token injection for deployment.

**Steps:**

1. Write a script to call the Permissions API to retrieve a token for a whitelisted wallet address
   [as detailed here](https://github.com/matter-labs/zksync-prividium/blob/main/experiments/sample-deploy-scripts/src/utils/get-crypto-native-auth.ts).

2. Use the token with `cast`:
   ```bash
   cast send \
     --rpc-url $PRIVIDIUM_RPC_URL \
     --account YOUR-ACCOUNT \
     --headers "Authorization: Bearer $TOKEN" \
     --create "$(jq -r '.bytecode.object' out/Greeter.sol/Greeter.json)"
   ```

> [!NOTE] The `--headers` flag allows you to inject custom headers, including the Authorization header with your token.

### Contract Deployment Permissions

Before deploying, ensure:

- Your user account has deployment permissions
- Your wallet address is whitelisted for contract deployment
- You have authenticated and obtained a valid token

Contact your Prividium network administrator to request deployment permissions if needed.

## Configuring Contract Method Permissions

After deploying a contract, you must whitelist the contract and configure permissions for each contract method in the
Prividium Admin Panel. By default, all contract functions are set to **"Forbidden"**, meaning no user can call them
until permissions are configured.

**Important:** All permissions require user authentication via OIDC/JWT. Users must be authenticated to call contract
functions.

1. **Navigate to Contract Details:** In the admin panel, find your contract and click to view details.

2. **View Function List:** The contract details page shows all functions from the contract ABI.

3. **Edit Permissions:** For each function:
   - Select the permission type (Forbidden, All Users, Check Role, etc.)
   - If using role-based permissions, select the required role(s)
   - If using argument restrictions, select which argument index(es) to restrict
   - Save the configuration

4. **Verify Configuration:** After saving, permissions are immediately active. Test by calling the function from your
   application.

### Permission Enforcement

**Read Functions (`view`/`pure`):**

- Permissions are checked when the function is called via `eth_call`
- Unauthorized calls return an error

**Write Functions (`nonpayable`/`payable`):**

- Permissions are checked for both:
  - Simulation (`eth_call` - when estimating gas or simulating)
  - Execution (`eth_sendRawTransaction` - when actually sending the transaction)
- Both checks must pass for the transaction to succeed

## Application Configuration

Before building your application, you need to configure the following essential components:

### 1. Register OAuth Client

1. **Access Admin Panel**: Navigate to your Prividium Admin Panel
2. **Create Application**: Register a new Application client and obtain your `CLIENT_ID`
3. **Configure CORS**: Add your application's origin URL to the allowed CORS origins in the client configuration
4. **Set Redirect URL**: Configure the callback URL (typically `https://your-app.com/callback`) where users will be
   redirected after authentication

### 2. Configure Application URLs

Your application needs to know where to connect to Prividium services:

- **RPC URL**: The base proxy RPC endpoint (e.g., `https://proxy.prividium.dev/rpc`)
- **Permissions API URL**: The Permissions API base URL (e.g., `https://permissions-api.prividium.dev`)
- **Auth Base URL**: The authentication service URL (e.g., `https://user-panel.prividium.dev`)
- **Callback URL**: Your application's callback route (must match the redirect URL configured in the OAuth client)

### 3. Chain Configuration

Configure your application to connect to the correct Prividium chain:

- **Chain ID**: The chain ID of your Prividium network
- **Chain Metadata**: Display name, native currency details, and block explorer URL (if applicable)

Initialize the Prividium SDK using `createPrividiumChain()`:

```typescript
import { createPrividiumChain } from 'prividium';
import { defineChain } from 'viem';

// Define your Prividium chain
const prividiumChain = defineChain({
  id: parseInt(process.env.CHAIN_ID || '8022834'),
  name: process.env.CHAIN_NAME || 'Prividium',
  nativeCurrency: {
    name: process.env.NATIVE_CURRENCY_NAME || 'ETH',
    symbol: process.env.NATIVE_CURRENCY_SYMBOL || 'ETH',
    decimals: parseInt(process.env.NATIVE_CURRENCY_DECIMALS || '18')
  },
  rpcUrls: {
    default: {
      http: [process.env.RPC_URL || 'https://proxy.prividium.dev/rpc']
    }
  },
  blockExplorers: process.env.BLOCK_EXPLORER_URL
    ? {
        default: {
          name: 'Explorer',
          url: process.env.BLOCK_EXPLORER_URL
        }
      }
    : undefined
});

// Initialize Prividium SDK
const prividium = createPrividiumChain({
  clientId: process.env.CLIENT_ID || process.env.PRIVIDIUM_CLIENT_ID,
  chain: prividiumChain,
  rpcUrl: process.env.RPC_URL || 'https://proxy.prividium.dev/rpc',
  authBaseUrl: process.env.AUTH_BASE_URL || 'https://user-panel.prividium.dev',
  permissionsApiBaseUrl: process.env.PERMISSIONS_API_BASE_URL || 'https://permissions-api.prividium.dev',
  redirectUrl: process.env.AUTH_CALLBACK_URL || 'https://your-app.com/callback',
  onAuthExpiry: () => {
    console.log('Authentication expired - please reconnect');
  }
});
```

**Note:** Adjust environment variable access based on your framework (e.g., `import.meta.env.*` for Vite,
`process.env.*` for Node.js).

## Authentication and OAuth Scopes

### Overview

Prividium uses OAuth 2.0 with popup-based authentication. The authentication flow determines what operations your
application can perform.

### OAuth Scopes

Prividium supports two OAuth scopes that control application capabilities:

- **`wallet:required`** - Ensures the user has at least one wallet address associated with their account
- **`network:required`** - Ensures the user has a wallet connected with the correct chain configuration

### Scope Selection

Your application should allow users to choose between read-only and full access:

```typescript
import { prividium } from './wagmi';
import type { OauthScope } from 'prividium';

// Read-only mode (no scopes)
const authOptionsReadOnly = {};

// Full access mode (with scopes)
const authOptionsFullAccess = {
  scopes: ['wallet:required', 'network:required'] as OauthScope[]
};

// Authenticate based on user choice
const authToken = await prividium.authorize(readOnlyMode ? authOptionsReadOnly : authOptionsFullAccess);
```

### Authentication Flow

1. User clicks authenticate button
2. SDK opens popup window with Prividium User Panel
3. User authenticates in popup
4. Popup redirects to `/callback` page
5. SDK handles callback and stores JWT token
6. Popup closes automatically
7. Main window receives authentication success

**Important:** The callback page must call `handleAuthCallback()`:

```typescript
// src/pages/Callback.tsx
import { handleAuthCallback } from 'prividium';

useEffect(() => {
  handleAuthCallback((errorMessage) => {
    if (errorMessage) {
      console.error('Authentication error:', errorMessage);
      // Handle error
    } else {
      // Authentication successful, popup will close
    }
  });
}, []);
```

### Token Storage

The Prividium SDK automatically manages token storage:

- **Storage key**: `prividium_jwt_${chainId}` in `localStorage`
- **OAuth state**: `prividium_auth_state_${chainId}` in `localStorage`
- **Read-only flag**: `prividium_read_only_access` in `localStorage` (custom)

**Note:** Never manually manage tokens. Always use the SDK's `isAuthorized()` and `getAuthHeaders()` methods.

## RPC URL Architecture

Prividium uses **different RPC endpoints** for read vs write operations:

- **Read Operations**: Use the authenticated `/rpc` endpoint via `prividium.transport` (automatically includes auth
  headers)
- **Write Operations**: Use the per-user `/wallet/{token}` endpoint configured in the user's wallet

> [!NOTE] Per-User RPC Details
>
> For comprehensive details on the per-user RPC URL architecture, transaction allowances, and wallet RPC behavior, see
> [Per-User RPC Documentation](../user-docs/30.per-user-rpc.md).

## Network Configuration

When users authenticate with wallet scopes (`wallet:required` and `network:required`), the Prividium authentication
system will prompt them to add the Prividium network to their wallet with a custom RPC endpoint (`/wallet/{token}`).
This per-user RPC endpoint enables secure transaction submission.

**Important:** The wallet must be configured with the `/wallet/{token}` RPC URL for write operations. This ensures
transactions are routed through Prividium's authenticated proxy.

## Browser Extension Wallets (MetaMask, etc.)

Browser extension wallets (like MetaMask) require a custom RPC endpoint configuration to work with Prividium.

### Why Custom RPC Endpoint is Required

Browser extension wallets **do not support authentication headers** in their RPC requests. This means they cannot use
the authenticated `/rpc` endpoint directly. Instead, they must use the per-user `/wallet/{token}` RPC endpoint, which
embeds the user's authentication token in the URL path rather than requiring headers.

> [!NOTE] Per-User RPC Details
>
> For comprehensive details on the per-user RPC URL architecture, token lifecycle, transaction allowances, and wallet
> RPC behavior, see [Per-User RPC Documentation](../user-docs/30.per-user-rpc.md).

### Authentication Provides RPC Endpoint

When users authenticate with wallet scopes (`wallet:required` and `network:required`), Prividium generates a
user-specific wallet token and provides a custom RPC endpoint (`/wallet/{token}`). This endpoint:

- **Embeds authentication in the URL** - No auth headers needed
- **Is user-specific** - Each authenticated user gets their own unique token
- **Enables transaction submission** - Required for write operations through browser wallets

### Configuration Flow

1. **User authenticates** with wallet scopes - This triggers the generation of a wallet token via the Permissions API
2. **Obtain the RPC URL** - Use `prividium.getWalletRpcUrl()` to retrieve the user's custom RPC endpoint
   (`/wallet/{token}`)
3. **Configure wallet network** - Use `prividium.addNetworkToWallet()` or manually configure the wallet with this RPC
   URL
4. **User connects wallet** - The user must still explicitly connect their browser wallet to your application
   (authentication alone does not automatically connect the wallet)

### Example Integration

```typescript
import { prividium } from './prividium-config';

// After user authenticates with wallet scopes
if (prividium.isAuthorized()) {
  // Get the user's custom RPC endpoint
  const walletRpcUrl = await prividium.getWalletRpcUrl();
  // Returns: https://proxy.prividium.dev/wallet/{user-token}

  // Configure wallet network with this RPC URL
  await prividium.addNetworkToWallet();
  // This prompts the user to add the network to their wallet

  // User still needs to connect the wallet
  // This is a separate step from authentication
}
```

**Important:** Authentication provides the RPC endpoint configuration, but users must still explicitly connect their
browser wallet to your application. Authentication and wallet connection are separate steps.

## Scripting with Viem and Ethers

Unlike browser extension wallets, scripting tools like Viem and Ethers support authentication headers directly. This
means you can use the standard authenticated `/rpc` endpoint without needing the per-user `/wallet/{token}` endpoint.

### Key Advantage

Scripting tools can inject custom headers into their HTTP requests, allowing them to:

- Use the authenticated `/rpc` endpoint directly
- Include `Authorization: Bearer {token}` headers in requests
- Avoid the need for per-user RPC endpoint configuration

This makes scripting ideal for:

- Contract deployment scripts
- Automated transaction scripts
- Backend services interacting with Prividium chains

### Using Ethers.js

Ethers.js provides the `FetchRequest` class to configure custom headers:

```typescript
import { ethers, FetchRequest } from 'ethers';

// Get authentication token (from Permissions API)
const authToken = await getAuthToken();

// Create FetchRequest with auth header
const fetchRequest = new FetchRequest(rpcUrl);
fetchRequest.setHeader('Authorization', `Bearer ${authToken}`);

// Create provider with FetchRequest
const provider = new ethers.JsonRpcProvider(fetchRequest);

// Create signer with private key
const signer = new ethers.Wallet(privateKey, provider);

// Deploy contract
const contractFactory = new ethers.ContractFactory(contractAbi, contractBytecode, signer);
const contract = await contractFactory.deploy();
await contract.waitForDeployment();
```

### Using Viem

Viem's `http` transport supports `fetchOptions` to include custom headers:

```typescript
import { http, createPublicClient, createWalletClient } from 'viem';
import { privateKeyToAccount } from 'viem/accounts';

// Get authentication token (from Permissions API)
const authToken = await getAuthToken();

// Create transport with auth headers
const transport = http(rpcUrl, {
  fetchOptions: {
    headers: {
      Authorization: `Bearer ${authToken}`
    }
  }
});

// Create clients with authenticated transport
const publicClient = createPublicClient({
  chain: prividiumChain,
  transport,
  account: address // optional for read operations
});

const account = privateKeyToAccount(privateKey);
const walletClient = createWalletClient({
  account,
  chain: prividiumChain,
  transport
});

// Deploy contract
const hash = await walletClient.deployContract({
  abi: contractAbi,
  bytecode: contractBytecode
});
```

### Obtaining Authentication Tokens

For scripting scenarios, obtain authentication tokens by calling the Permissions API directly using crypto-native
authentication (SIWE - Sign-In With Ethereum):

1. **Request a SIWE message** - Call `POST /api/siwe-messages` with your wallet address and domain
2. **Sign the message** - Sign the returned SIWE message with your wallet's private key
3. **Authenticate** - Call `POST /api/auth/login/crypto-native` with the signed message to receive a session token

The session token can then be used as a Bearer token in the `Authorization` header for authenticated RPC requests.

**Note:** Ensure your wallet address has proper permissions to interact with the Prividium chain.

## Reading from Contracts

Use `prividium.transport` to create an authenticated RPC client for all read operations:

```typescript
import { getContract, createPublicClient } from 'viem';
import { prividium } from './prividium-config';

// Use wallet client or provide address
const accounts = await walletClient.getAddresses();
const address = accounts[0];

// Use wallet client or provide address
const accounts = await walletClient.getAddresses();
const address = accounts[0];

// Create authenticated RPC client
const rpcClient = createPublicClient({
  chain: prividium.chain,
  transport: prividium.transport,
  account: address // required for read from contract operations
});

// Read contract function
const contract = getContract({
  address: CONTRACT_ADDRESS,
  abi: CONTRACT_ABI,
  client: rpcClient
});

const value = await contract.read.getValue();
```

## Sending Transactions

### ⚠️ Critical Requirements

When sending transactions, you **MUST**:

1. Pre-fetch nonce, gas estimate, and gas price using the authenticated RPC client (`prividium.transport`)
2. Authorize transaction via `prividium.authorizeTransaction()`
3. Pass pre-fetched values to `walletClient.sendTransaction()`

**Why Pre-fetching is Required:** Wallets don't have authentication headers. By pre-fetching transaction parameters
using the authenticated client, the wallet only needs to sign and broadcast the transaction.

### Complete Transaction Pattern

```typescript
import { encodeFunctionData, createWalletClient, createPublicClient, custom } from 'viem';
import { createPrividiumClient } from 'prividium';
import { prividium } from './prividium-config';

const rpcClient = createPrividiumClient({
  chain: prividium.chain,
  transport: prividium.transport
});

const walletClient = createWalletClient({
  account: address,
  chain: prividium.chain,
  transport: custom(window.ethereum)
});

async function sendTransaction(contractAddress: Address, functionName: string, args: any[], value: bigint = 0n) {
  // Encode function data
  const data = encodeFunctionData({
    abi: CONTRACT_ABI,
    functionName,
    args
  });

  // Pre-fetch transaction parameters using authenticated client
  const nonce = await rpcClient.getTransactionCount({ address });
  const gas = await rpcClient.estimateGas({
    account: address,
    to: contractAddress,
    data
  });
  const gasPrice = await rpcClient.getGasPrice();

  // Authorize transaction (REQUIRED before each transaction)
  await prividium.authorizeTransaction({
    walletAddress: address,
    contractAddress,
    nonce,
    calldata: data,
    value: value
  });

  // Send transaction with pre-fetched values
  const hash = await walletClient.sendTransaction({
    account: address,
    to: contractAddress,
    data,
    nonce,
    gas,
    gasPrice
  });

  return hash;
}
```

### Transaction Allowance

**Critical:** You must call `prividium.authorizeTransaction()` before **every transaction**. Permission is
transaction-specific and expires after 1 hour.

> [!NOTE] Transaction Allowance Details
>
> For detailed information about transaction allowances, their lifecycle, and how they work with the per-user RPC
> endpoint, see [Per-User RPC Documentation](../user-docs/30.per-user-rpc.md#transaction-allowances).

```typescript
await prividium.authorizeTransaction({
  walletAddress: address,
  contractAddress,
  nonce,
  calldata: encodedFunctionData,
  value: transactionValue ?? 0n
});
```

## Error Handling

### Common Errors and Solutions

#### 401 Unauthorized on Read Operations

**Cause:** Not using authenticated transport

**Solution:**

```typescript
// ❌ Wrong - uses MetaMask RPC (no auth headers)
const client = createPublicClient({
  chain: prividium.chain,
  transport: custom(window.ethereum),
  account: address
});

// ✅ Correct - uses authenticated transport
const client = createPublicClient({
  chain: prividium.chain,
  transport: prividium.transport, // Includes auth headers
  account: address
});
```

#### Error "RPC method eth_call requires an account to be provided for the client"

**Cause:** Missing `account` in RPC client for read operations

**Solution:**

```typescript
// ❌ Wrong - uses MetaMask RPC (no auth headers)
const client = createPublicClient({
  chain: prividium.chain,
  transport: custom(window.ethereum),
  account: undefined
});

const contract = getContract({
  address: CONTRACT_ADDRESS,
  abi: CONTRACT_ABI,
  client: rpcClient
});

contract.read.getGreeting(); // Fails with error

// ✅ Always provide account before read operations
const client = createPublicClient({
  chain: prividium.chain,
  transport: prividium.transport,
  account: address // Required for reading from contracts
});

const contract = getContract({
  address: CONTRACT_ADDRESS,
  abi: CONTRACT_ABI,
  client: rpcClient
});

contract.read.getGreeting(); // Succeeds
```

#### 401 Unauthorized on Write Operations

**Cause:** Missing transaction allowance or not pre-fetching parameters

**Solution:**

```typescript
// ✅ Always enable wallet token before sending
await prividium.authorizeTransaction({
  walletAddress: address,
  contractAddress,
  nonce,
  calldata: data,
})

// ✅ Always pre-fetch using authenticated client
const nonce = await rpcClient.getTransactionCount({ address })
const gas = await rpcClient.estimateGas({ ... })
const gasPrice = await rpcClient.getGasPrice()
```

#### "Wallet is on wrong network"

**Cause:** MetaMask not configured with `/wallet/{token}` RPC URL

**Solution:**

```typescript
// Ensure network is configured before transactions
await ensureWalletReady(); // Calls addNetworkToWallet() if needed
```

## Best Practices

### 1. Always Use SDK Methods

```typescript
// ✅ Correct
const isAuth = prividium.isAuthorized();
const headers = prividium.getAuthHeaders();

// ❌ Wrong - don't access localStorage directly
const token = localStorage.getItem('prividium_jwt_...');
```

### 2. Handle Read-Only Mode

Check if the user authenticated in read-only mode and disable write operations accordingly:

```typescript
// Check if user authenticated in read-only mode
const isReadOnly = localStorage.getItem('prividium_read_only_access') === 'true';

// Only enable write operations if not read-only
if (!isReadOnly) {
  // Enable transaction sending UI
}
```

## Summary

Key takeaways for building on Prividium:

1. **Authentication**: Use SDK's popup-based OAuth flow with appropriate scopes
2. **Reads**: Always use `prividium.transport` (authenticated `/rpc` endpoint)
3. **Writes**: Pre-fetch nonce, gas, gas price using authenticated client, authorize wallet transaction, then send via
   MetaMask
4. **Network**: Configure MetaMask with `/wallet/{token}` RPC URL via `addNetworkToWallet()`
5. **Environment**: Use base proxy URL in your RPC URL environment variable, SDK constructs wallet URLs automatically
6. **Errors**: Handle 401 errors by ensuring authenticated clients and transaction allowances

Following these patterns ensures secure, reliable interactions with Prividium chains.
